#include <STC8G.h>

//11.0592MHZ烧录，20MS检测，和另一个一样

//下面这两个是一样的功能

/*

//这个两组功能是一样的，但是有一种区别，就是用光电开关输出角必须要连在输入角才行。
//这个标准双向口，如果没有连接光电输入脚，那么输出脚会不停的抖动开关。开漏模式就没有这种情况。

1. 第一组： P3M1 = 0x00; P3M0 = 0xFF; 
• 操作方式：这是一种比较直接、批量的设置方式。通过将 P3M1 设置为 0x00 （二进制 00000000 ），一次性清除了 P3M1 寄存器所有可能影响输出模式的设置。而将 P3M0 设置为 0xFF （二进制 11111111 ），则是同时开启了P3口所有引脚对应的强推挽输出相关的设置。这种方式是对整个P3口进行统一操作，就像是给一组设备全部开启同一种功能。
• 适用场景：适用于需要将整个P3口所有引脚都设置为强推挽输出的情况，比如当你连接了多个需要强驱动能力的外部设备到P3口的各个引脚，并且希望用一种简单、统一的方式进行配置时。 2. 第二组： P3M0 |= 0x08; P3M1 &= ～0x08; 
• 操作方式：这是一种针对特定引脚（P3.3）的精细设置方式。 P3M0 |= 0x08 （二进制 00001000 ）操作是通过按位或运算，在 P3M0 寄存器中单独将与P3.3引脚对应的位设置为 1 ，开启该引脚的强推挽输出相关功能。 P3M1 &= ～0x08 操作则是通过按位与运算和取反操作，将 P3M1 寄存器中与P3.3引脚对应的位设置为 0 ，清除可能干扰该引脚强推挽输出的其他模式设置。这种方式就像是在一组设备中，只对其中一个设备进行特定功能的设置，而不影响其他设备。
• 适用场景：适用于只需要将P3口中的P3.3引脚设置为强推挽输出，而其他引脚可能已经有其他用途或者设置，不想对它们进行干扰的情况。例如，P3口的其他引脚可能已经连接了一些正常工作的设备，并且输出模式不能被改变，现在只想将P3.3引脚设置为强推挽输出以连接一个新的、需要强驱动的设备。 3. 第三组： P3M0 &= ~(1 << P3_3_BIT); P3M1 &= ~(1 << P3_3_BIT); P3M0 |= (1 << P3_3_BIT); 
• 操作方式：这组代码也是针对特定引脚（P3.3）的设置方式。首先， P3M0 &= ~(1 << P3_3_BIT) 和 P3M1 &= ~(1 << P3_3_BIT) 这两步操作是通过先左移 1 定位到P3.3引脚在寄存器中的位，然后取反并进行按位与操作，分别清除 P3M0 和 P3M1 寄存器中与P3.3引脚相关的位之前的设置。最后 P3M0 |= (1 << P3_3_BIT) 通过左移 1 定位到P3.3引脚在 P3M0 寄存器中的位，再通过按位或操作将该位设置为 1 ，从而实现将P3.3引脚设置为强推挽输出。这种方式和第二组类似，也是精细地针对单个引脚进行操作，但操作步骤更细致，先清除可能的干扰设置，再进行强推挽输出的设置。
• 适用场景：同样适用于只想将P3.3引脚设置为强推挽输出的情况，尤其是当对寄存器之前的设置情况不太确定，或者担心之前的设置可能会干扰强推挽输出模式的正确配置时，这种先清除再设置的方式能够更可靠地将P3.3引脚配置为强推挽输出。
我们来分析第四组。
第四组： P3M1 &= ~(1 << 3); P3M0 &= ~(1 << 3); 
• 操作方式：
• 对于 P3M1 &= ~(1 << 3) ， 1 << 3 表示将1（二进制为00000001）左移3位，得到00001000，这对应着P3.3引脚在寄存器中的位。 ~(1 << 3) 是对其取反，得到11110111。然后 P3M1 &= ~(1 << 3) 通过按位与操作，将 P3M1 寄存器中对应P3.3引脚的位清零。
• 对于 P3M0 &= ~(1 << 3) ，操作类似，也是将 P3M0 寄存器中对应P3.3引脚的位清零。这组代码整体上是清除P3.3引脚在 P3M1 和 P3M0 寄存器中的相关位设置，通常这是设置推挽输出（非强推挽）模式的步骤。
• 与强推挽模式设置的不同：
• 强推挽输出一般需要在 P3M0 寄存器中设置相应位为1来开启强驱动相关功能。而这组代码并没有开启这个功能，只是清除相关位，很可能是配置普通推挽输出或者为了后续其他输出模式（如开漏输出等）做准备，而不是设置强推挽输出。
• 与前面几组强推挽输出设置相比，这组代码缺少了关键的将 P3M0 中对应位设置为1的步骤，所以不能实现强推挽输出，其功能重点在于清除之前可能存在的设置干扰，为其他输出模式配置服务。
1. 多数芯片能正常工作的原因
• 对于大多数芯片而言，代码中的基本逻辑和常规的GPIO（通用输入输出）配置在正常情况下是可以满足要求的。例如，在正常的输入输出模式设置下，当输出负载（如继电器）对输出电流的要求在芯片引脚能够提供的范围内时，芯片可以按照预期工作。其内部的电路结构和电气特性能够支持代码所设定的诸如读取输入引脚状态（光电开关状态）和设置输出引脚电平（控制继电器）等操作。 2. 个别芯片输出能力不足的原因
• 芯片个体差异：尽管是同型号的STC8G 1K 08A芯片，但在制造过程中可能会存在一定的工艺偏差。这会导致个别芯片的某些电气参数（如输出驱动能力）与标准值有所不同。可能这些芯片的输出级晶体管的特性导致其无法提供足够的电流来驱动外部负载（如继电器），使得输出表现为能力不足。
• 外部因素影响：外部环境因素也可能对芯片的性能产生影响。例如，电源的稳定性、电磁干扰等情况。如果电源波动较大，可能会影响芯片输出级的供电情况，导致输出功率不足。或者在存在较强电磁干扰的环境下，芯片内部电路的工作状态可能会受到干扰，进而影响其输出能力。 3. 强推挽模式解决问题的原理
• 强推挽输出模式能够增强芯片引脚的输出驱动能力。在这种模式下，芯片内部的输出级电路可以提供更大的电流来驱动外部负载。当把引脚（如P3.3）设置为强推挽输出模式时，能够有效地克服个别芯片由于自身电气参数差异或外部因素导致的输出电流不足的问题，从而使继电器等外部设备能够正常工作。
1. 准双向IO口模式（默认模式）
• 代码设置（恢复默认）：
• c
P5M0 |= (1 << 4); // 将P5.4对应的M0寄存器位置1 P5M1 &= ~(1 << 4); // 将P5.4对应的M1寄存器位清零  
• 功能特点：
• 这是最常用的模式，当作为输入时，引脚内部有上拉电阻（弱上拉）。读取引脚状态时，如果外部没有强驱动信号，读取到的是高电平；当外部信号拉低引脚时，能正确读取到低电平。作为输出时，可以正常输出高电平和低电平，输出电流能力有限。这种模式适合连接按键（内部上拉电阻可以简化电路）、连接一些数字逻辑器件的普通输入输出接口等。 2. 开漏模式
• 代码设置：
• c
P5M0 &= ~(1 << 4); // 将P5.4对应的M0寄存器位清零 P5M1 &= ~(1 << 4); // 将P5.4对应的M1寄存器位清零  
• 功能特点：
• 开漏输出模式下，当输出低电平时，引脚直接接地；当输出高电平时，引脚处于高阻态（相当于断开）。这种模式主要用于需要实现线与功能的场合，例如多个开漏输出引脚连接在一起，只要有一个引脚输出低电平，整条线路就是低电平。在驱动外部设备时，需要外部接上拉电阻来实现高电平输出。对于输入功能，它的输入特性和准双向口类似，但由于其特殊的输出结构，在某些应用场景下可以灵活地控制信号的传输。 3. 高阻输入模式（前面已提及部分代码）
• 代码设置：
• c
P5M0 &= ~(1 << 4); // 将P5.4对应的M0寄存器位清零 P5M1 |= (1 << 4); // 将P5.4对应的M1寄存器位置1  
• 功能特点：
• 在高阻输入模式下，引脚的输入阻抗非常高，几乎不消耗外部信号源的电流。它相当于引脚与内部电路断开，外部信号可以直接驱动引脚，不会受到单片机内部电路的干扰。这种模式适用于连接外部信号源，例如连接一些高精度的模拟信号输入（需要配合模数转换模块）或者连接其他设备的输出引脚，并且希望对外部信号的影响降到最低的情况。 4. 推挽输出模式
• 代码设置：
• c
P5M0 &= ~(1 << 4); // 将P5.4对应的M0寄存器位清零 P5M1 |= (1 << 4); // 将P5.4对应的M1寄存器位置1，这里和高阻输入模式设置相同，但后续的操作方向是输出  
• 功能特点：
• 推挽输出模式下，当输出高电平时，引脚通过一个上管（P - MOS管）连接到电源；当输出低电平时，引脚通过一个下管（N - MOS管）连接到地。这种模式可以提供较大的输出电流，能够直接驱动一些功率稍大的负载，如小型继电器、LED（需要合适的限流措施）等，输出电平的切换速度也相对较快，在需要快速驱动外部设备或者需要较强的驱动能力时很有用。不过，在配置为推挽输出时，要注意避免引脚短路等情况。
// 初始化GPIO
void GPIO_Init(void) {
   // 设置P5.4为标准双向口输入模式
	
    P5M0 &= ~0x10;  // P5.4设置为标准双向口模式，对应二进制第4位设置为0（11110111）
    P5M1 &= ~0x10;

    // 设置P3.3为输出模式
    P3M0 |= 0x08;  // P3.3设置为强推挽输出模式，对应二进制第3位设置为1（00001000）
    P3M1 &= ~0x08;
    P33 = 0; // 默认设置P3.3为低电平，继电器关闭
}

// 初始化GPIO
void GPIO_Init(void) {
   // 设置P5.4为开漏输入模式
	
    P5M0 &= ~(1 << 4);  // 将P5.4对应的M0寄存器位清零
    P5M1 &= ~(1 << 4); // 将P5.4对应的M1寄存器位清零
    // 设置P3.3为输出模式
    P3M0 |= 0x08;  // P3.3设置为强推挽输出模式，对应二进制第3位设置为1（00001000）
    P3M1 &= ~0x08;

    P33 = 0; // 默认设置P3.3为低电平，继电器关闭
}

*/

//这个代码和其它不同之处是一经烧录测试有个别芯片不能正常工作的情况发生，改为下面的其它强推挽输出模式，解决输出电流能力不足问题

//输入IO口没有相应配置模式，下面没有配置输入脚，为空，输入脚要加电阻20欧，否则输入脚电压（检测输入脚）超过芯片电压，会有烧毁的风险

//经测试输入脚串联电阻可用20欧

//这个是用于个别芯片，光电开关不能正常输出高低电平，接在芯片输入脚，光电开关不能正常工作的情况，
//同时最主要的是芯片问题，光电开关用在其它芯片都没有这种情况,不同批次的芯片，体质不一样，所以会出现同样的程序，
//不同批次的芯片，使用同样的程序也会，出现个别情况发生，有的能正常工作，有的却不能正常工作

// 延时函数
void delay(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 123; j++); // 调整此值以改变延时时间
    }
}

// 初始化GPIO
void GPIO_Init(void) {
   // 设置P5.4为开漏输入模式
	
    P5M0 &= ~(1 << 4);  // 将P5.4对应的M0寄存器位清零
    P5M1 &= ~(1 << 4); // 将P5.4对应的M1寄存器位清零
    // 设置P3.3为输出模式
    P3M0 |= 0x08;  // P3.3设置为强推挽输出模式，对应二进制第3位设置为1（00001000）
    P3M1 &= ~0x08;

    P33 = 0; // 默认设置P3.3为低电平，继电器关闭
}

// 控制继电器开
void Relay_On(void) {
    P33 = 1; // 设置P3.3为高电平，继电器开启
}

// 控制继电器关
void Relay_Off(void) {
    P33 = 0; // 设置P3.3为低电平，继电器关闭
}

// 继电器状态标志
bit relay_state = 0; // 继电器状态标志，0表示关闭，1表示开启

// 检查光电开关状态并控制继电器
void Check_Sensor(void) {
    static bit last_sensor_state = 1; // 上一次的传感器状态，默认为未触发
    bit current_sensor_state;          // 当前传感器状态

    // 获取当前传感器状态
    current_sensor_state = (P5 & (1 << 4)) ? 1 : 0;

    // 如果传感器状态发生变化，则进行消抖处理
    if (current_sensor_state != last_sensor_state) {
        delay(20); // 延时20ms以消除抖动

        // 再次获取当前传感器状态，确保状态变化是真实的
        current_sensor_state = (P5 & (1 << 4)) ? 1 : 0;

        // 如果状态确实变化了，则根据继电器状态决定操作
        if (current_sensor_state != last_sensor_state) {
            if (current_sensor_state == 0 && !relay_state) { // 光电开关被遮挡且继电器关闭
                Relay_On();         // 开启继电器
                relay_state = 1;    // 更新继电器状态
            } else if (current_sensor_state == 0 && relay_state) { // 光电开关被遮挡且继电器开启
                Relay_Off();        // 关闭继电器
                relay_state = 0;    // 更新继电器状态
            }

            // 更新上次传感器状态
            last_sensor_state = current_sensor_state;
        }
    }
}

// 主函数
void main(void) {
    GPIO_Init(); // 初始化GPIO
    
    while (1) {
        Check_Sensor(); // 检查光电开关状态
    }
}
