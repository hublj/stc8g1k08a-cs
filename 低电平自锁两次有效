#include "STC8G.h"
#include <intrins.h>

// 定义 P3.3 对应的位
#define P3_3_BIT 3
// 定义 P5.4 对应的位
#define P5_4_BIT 4

// 配置 P3.3 为强推挽输出模式，P5.4 为输入模式
void init_gpio() {
    // 设置 P3.3 为强推挽输出模式
    P3M0 &= ~(1 << P3_3_BIT);
    P3M1 &= ~(1 << P3_3_BIT);
    P3M0 |= (1 << P3_3_BIT);

    // 设置 P5.4 为输入模式
    P5M0 &= ~(1 << P5_4_BIT);
    P5M1 &= ~(1 << P5_4_BIT);
    P5M0 |= (1 << P5_4_BIT);
}

// 更精确的延时函数，使用定时器，这里只是示例，需要根据实际调整
void delay_ms(unsigned int ms) {
    // 假设定时器已经初始化，这里设置定时器重装值来实现延时
    // 以下代码仅为示意，需根据实际单片机定时器配置修改
    TMOD &= 0xF0;
    TMOD |= 0x01;
    TH0 = (65536 - 110592 / 12 * ms / 1000) / 256;
    TL0 = (65536 - 110592 / 12 * ms / 1000) % 256;
    TR0 = 1;
    while (!TF0);
    TF0 = 0;
    TR0 = 0;
}

// 主函数实现主要功能
void main() {
    unsigned char count = 0; // 在这里明确添加 count 的定义
    init_gpio();
    P3 |= (1 << P3_3_BIT); // 初始状态为关闭输出，P3.3 为高电平

    while (1) {
        if ((P5 & (1 << P5_4_BIT)) == 0) { // 检测到光电开关触发（低电平）
            delay_ms(10); // 短延时防抖
            if ((P5 & (1 << P5_4_BIT)) == 0) {
                count++;
                if (count % 2 == 1) { // 奇数次触发
                    // 设置 P3.3 为强推挽输出模式
                    P3M0 &= ~(1 << P3_3_BIT);
                    P3M1 &= ~(1 << P3_3_BIT);
                    P3M0 |= (1 << P3_3_BIT);
                    P3 &= ~(1 << P3_3_BIT); // 输出低电平，开启
                } else { // 偶数次触发
                    // 设置 P3.3 为高阻输入模式，避免影响光电开关
                    P3M0 &= ~(1 << P3_3_BIT);
                    P3M1 &= ~(1 << P3_3_BIT);
                    P3M0 |= (0 << P3_3_BIT);
                    P3 |= (1 << P3_3_BIT); // 输出高电平，关闭
                }
            }
        }
    }
}
